<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>  Kosmgco | [翻译]Golang 中的微服务 </title>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<link href="https://blog.ooops.me/theme/css/github-markdown.css" rel="stylesheet"/>
<link href="https://blog.ooops.me/theme/css/custom.css" rel="stylesheet"/>
<meta name="baidu-site-verification" content="qfSD7JIuUr"/>
<meta name="description" content="Linux. Python. Coder. Gopher."/>
<meta name="author" content="kosmgco" />

<meta name="viewport" content="width=device-width, initaial-scale=1"/>  </head>
  <body class="markdown-body">
    <style>
      @media (max-width: 550px) {
        .catalog, .content {
          display:none;
        }
      }
    </style>
    <div class="menu">
      <div class="title" style="background: url(https://static.ooops.me/md-upload-1536468495519.png) no-repeat; background-position: center"></div>
      <h3> Kosmgco </h3>
      <h4> Linux. Python. Coder. Gopher. </h4>
      <div class="links-menu" >
        <a href="https://blog.ooops.me/" class="menu-link" title="HOME"><img src="/theme/images/home.png" width="40"/></a>
        <a href="https://blog.ooops.me/tags.html" class="menu-link" title="TAGS"><img src="/theme/images/tags.png" width="40"/></a>
        <a href="https://blog.ooops.me/categories.html" class="menu-link" title="CATEGORIES"><img src="/theme/images/categories.png" width="40"/></a>
        <a href="https://blog.ooops.me/pages/about.html" class="menu-link" title="ABOUT"><img src="/theme/images/about.png" width="40"/></a>
        <a href="https://blog.ooops.me/pages/wiki.html" class="menu-link" title="WIKI"><img src="/theme/images/wiki.png" width="40"/></a>
        <a href="https://blog.ooops.me/pages/blog.html" class="menu-link" title="BLOG"><img src="/theme/images/blog.png" width="40"/></a>
 
      </div>
      <div class="links">
        <a href="http://github.com/kosmgco" target="_blank">
          <img src="https://blog.ooops.me/theme/images/github-128.png" style="width:32px;">
        </a>
        <a href="mailto:i@ooops.me" target="_blank">
          <img src="https://blog.ooops.me/theme/images/mail-128.png" style="width:32px;">
        </a>
        <a href="/atom.xml" target="_blank">
          <img src="https://blog.ooops.me/theme/images/rss-128.png" style="width:32px;">
        </a>
      </div>
      <div class="links">
        <a href="http://xlzd.me" target="_blank">xlzd杂谈</a>
        <a href="http://midday.me" target="_blank">正午的博客</a>
        <a href="http://mqhong.com" target="_blank">梦梦的咸鱼</a>
        <a href="http://bilibili.ooops.me" target="_blank">B站弹幕</a>
      </div>
      <div class="copyright">
        &copy <a href="/">Kosmgco</a>. <script>document.write(new Date().getFullYear());</script><br />
        Powered by <a href="https://getpelican.com" target="_blank">Pelican</a>. Theme by <a href="https://github.com/kosmgco/pelican-theme-mdshow" target="_blank">MDShow</a> 
        <br />
        <a href="https://www.miitbeian.gov.cn/" target="_blank">渝ICP备16003403号</a>
      </div>
    </div>
    <div class="catalog">
      <b>2019-08-23</b><a href="https://blog.ooops.me/posts/2019/08/23/zuo-liao-ji-ge-xiao-cheng-xu-lian-shou.html">做了几个小程序练手</a>
      <b>2018-12-26</b><a href="https://blog.ooops.me/posts/2018/12/26/sou-suo-yin-qing-jie-guo-zi-ding-yi-gui-ze-guo-lu-chromecha-jian.html">搜索引擎结果自定义规则过滤Chrome插件</a>
      <b>2018-12-18</b><a href="https://blog.ooops.me/posts/2018/12/18/mac-shadowsocks-duo-fu-wu-qi-shi-yong-haproxy-fu-zai-jun-heng-qi.html">Mac Shadowsocks 多服务器使用 HAProxy 负载均衡器</a>
      <b>2018-11-08</b><a href="https://blog.ooops.me/posts/2018/11/08/shi-yong-fail2ban-bao-hu-fu-wu-qi.html">使用 fail2ban 保护服务器</a>
      <b>2018-01-16</b><a href="https://blog.ooops.me/posts/2018/01/16/golang-json-zi-ding-yi-lei-xing-de-xu-lie-hua-yu-fan-xu-lie-hua.html">Golang JSON 自定义类型的序列化与反序列化</a>
      <b>2017-10-22</b><a href="https://blog.ooops.me/posts/2017/10/22/pai-xu-cha-ru-pai-xu.html">排序 - 插入排序</a>
      <b>2017-10-20</b><a href="https://blog.ooops.me/posts/2017/10/20/pai-xu-xuan-ze-pai-xu.html">排序 - 选择排序</a>
      <b>2017-09-21</b><a href="https://blog.ooops.me/posts/2017/09/21/golang-3des-des-aesjia-mi-jie-mi.html">Golang 3DES, DES, AES加密解密</a>
      <b>2017-09-16</b><a href="https://blog.ooops.me/posts/2017/09/16/zi-ji-shi-xian-shi-xian-yi-ge-zhan.html">自己实现实现一个栈</a>
      <b>2017-07-30</b><a href="https://blog.ooops.me/posts/2017/07/30/mysqlji-zhu-nei-mu-innodbcun-chu-yin-qing-di-yi-zhang.html">《MySQL技术内幕: InnoDB存储引擎》 - 第一章</a>
      <b>2017-07-08</b><a href="https://blog.ooops.me/posts/2017/07/08/nginxri-zhi-fen-xi.html">Nginx日志分析</a>
      <b>2017-02-24</b><a href="https://blog.ooops.me/posts/2017/02/24/tong-guo-ren-lian-shi-bie-huo-qu-xue-xiao-xue-sheng-de-xing-bie-bi-li.html">通过人脸识别获取学校学生的性别比例</a>
      <b>2016-12-10</b><a href="https://blog.ooops.me/posts/2016/12/10/kai-qi-quan-zhan-https.html">开启全站https</a>
      <b>2016-12-04</b><a href="https://blog.ooops.me/posts/2016/12/04/say-hello-world-to-docker.html">Say Hello-World! To Docker</a>
      <b>2016-10-25</b><a href="https://blog.ooops.me/posts/2016/10/25/ubuntu-gokai-fa-huan-jing-pei-zhi.html">Ubuntu-Go开发环境配置</a>
      <b>2016-07-19</b><a href="https://blog.ooops.me/posts/2016/07/19/shi-yong-python-flaskda-jian-qing-bo-ke.html">使用Python-Flask搭建轻博客</a>
      <b>2016-07-10</b><a href="https://blog.ooops.me/posts/2016/07/10/appfan-bian-yi.html">app反编译</a>
      <b>2016-07-10</b><a href="https://blog.ooops.me/posts/2016/07/10/gitcao-zuo.html">git操作</a>
      <b>2016-07-10</b><a href="https://blog.ooops.me/posts/2016/07/10/ubnntupei-zhi-shadowsockske-xue-shang-wang.html">Ubnntu配置shadowsocks科学上网</a>
      <b>2016-04-16</b><a href="https://blog.ooops.me/posts/2016/04/16/nginx-virtual-hostxu-ni-ji.html">nginx virtual host虚拟机</a>
      <b>2016-03-25</b><a href="https://blog.ooops.me/posts/2016/03/25/shi-xi-zong-jie.html">实习总结</a>
      <b>2016-03-04</b><a href="https://blog.ooops.me/posts/2016/03/04/wei-xin-gong-zhong-hao-yi-ji-zhi-neng-liao-tian-ji-qi-ren-de-jie-ru.html">微信公众号以及智能聊天机器人的接入</a>
      <b>2016-02-27</b><a href="https://blog.ooops.me/posts/2016/02/27/jia-su-le-cookie__jsl_clearnce-po-jie-xin-jin-zhan.html">加速乐cookie:__jsl_clearnce 破解新进展</a>
      <b>2016-02-23</b><a href="https://blog.ooops.me/posts/2016/02/23/fu-li-tie-shi-yong-ubermian-fei-zuo-zhuan-che.html">福利帖 - 使用uber免费坐专车</a>
      <b>2016-02-02</b><a href="https://blog.ooops.me/posts/2016/02/02/pycharmandroid-studioyuan-an-zhuang.html">Pycharm,Android-Studio源安装</a>
      <b>2016-01-17</b><a href="https://blog.ooops.me/posts/2016/01/17/pythonpa-qu-tu-pian.html">python爬取图片</a>
      <b>2016-01-10</b><a href="https://blog.ooops.me/posts/2016/01/10/zheng-fang-jiao-wu-xi-tong-shu-ju-huo-qu.html">正方教务系统数据获取</a>
      <b>2015-12-24</b><a href="https://blog.ooops.me/posts/2015/12/24/flask-wen-jian-jie-gou-zu-zhi.html">flask 文件结构组织</a>
      <b>2015-12-21</b><a href="https://blog.ooops.me/posts/2015/12/21/mongodb-xiao-dao-chu-shi.html">mongodb 小刀初试</a>
      <b>2015-12-20</b><a href="https://blog.ooops.me/posts/2015/12/20/guan-yu-shua-piao.html">关于刷票</a>
      <b>2015-12-18</b><a href="https://blog.ooops.me/posts/2015/12/18/python-jsonjie-xi-na-dian-shi.html">python json解析那点事</a>
      <b>2015-12-12</b><a href="https://blog.ooops.me/posts/2015/12/12/flask-chu-kui.html">flask 初窥</a>
      <b>2015-12-09</b><a href="https://blog.ooops.me/posts/2015/12/09/guan-yu-jia-su-le-de-__jsl_clearancefan-hui-521zhuang-tai-ma-po-jie.html">关于加速乐的__jsl_clearance返回521状态码破解</a>
    </div>
    <div class="content">
  <style>
    @media(max-width: 550px) {
      body {
        height: auto;
      }
      .menu .links, .menu .copyright {
        display:none;
      }
      .menu {
        height: 65%;
      }
      .catalog {
        display:none;
      }
      .content {
        display: block;
      }
      h3 {
        text-align: center;
      }
    }
  </style>
  <h3> [翻译]Golang 中的微服务 </h3>
    <a href="https://blog.ooops.me/tag/microservice.html" class="link-tags">microservice</a>
    <a href="https://blog.ooops.me/tag/golang.html" class="link-tags">golang</a>
    <a href="https://blog.ooops.me/tag/docker.html" class="link-tags">docker</a>
    <a href="https://blog.ooops.me/tag/go-micro.html" class="link-tags">go-micro</a>
  <hr style="clear:both"/>
  <h1>Golang 与微服务 - 第二部分 Docker 与 go-micro</h1>
<p>在<a href="">前面一篇文章中</a>，我们介绍了编写基于 gRPC 的微服务的基础知识。在这一部分，我们会简单的介绍 Docker 化一个微服务，使用<code>go-micro</code>来升级我们的服务。最后，介绍第二个服务。</p>
<h2>Docker 简介</h2>
<p>随着云计算的出现与微服务的诞生。一次部署更多但是更小的代码块的压力产生了一些有趣的新的想法和技术。其中之一就是<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">容器</a>的概念。</p>
<p>在传统意义上来说，技术团队会部署一个大型应用到一个静态服务器，运行一系列的操作系统，以及一组预定义的依赖关系来跟踪。或许在Chef 或者 Puppet 供应的 VM 机器上。扩展是昂贵的，低效的。最通用的选项是竖向扩展，即在静态服务器上投放越来越多的资源。</p>
<p>像<a href="https://www.vagrantup.com">vagrant</a>这样的工具使供应大量的 VM 变得简单。但是运行一个 VM 仍然是一个相当有分量的操作。你在主机内运行一个完整的操作系统，包括所有的 glory，内核和所有的操作系统。在资源方面，这是相当贵的。因此当微服务的到来，在他们自己的环境中运行多个独立的代码库变得不可行。</p>
<h2>随之而来的容器</h2>
<p><a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">容器</a>是缩减版本的操作系统。容器不包含内核，一个访客操作系统或者一些构成典型操作系统的底层的组件。</p>
<p>容器仅仅包含顶层库和它的运行时组件。它的内核是与宿主机共享的的。因此，宿主机运行单个 Unix 内核，然后被 n 个运行不同运行时的容器共享。</p>
<p>在 hood 下，容器利用各种内核工具，以便能与宿主机共享资源和网络功能。</p>
<p><a href="https://www.redhat.com/en/topics/containers/whats-a-linux-container">了解更多</a></p>
<p>这就意味着你可以运行你的代码需要的运行时和依赖，而不需要启动多个完整的操作系统。这是一个规则改变者，因为一个容器的整体规模都比一个 VM 都要小。以 Ubuntu 举例来说，通常是不到1GB 大小的，而它的 Docker 镜像仅仅是188mb。</p>
<p>你会注意到我在这个介绍中更广泛的提到容器，而不是'Docker 容器'。因为普遍认为<a href="www.docker.com">Docker</a>和容器是同一件事。然而，容器在 Linux 更多的是一个概念或一组功能。<a href="https://www.docker.com">Docker</a>只是容器的一个分类，但是因为它使用简单越来越受欢迎。也有<a href="https://www.contino.io/insights/betond-docker-other-types-of-containers">其他的</a>容器。但是我们仍然坚持使用 Docker，因为在我看来Docker对首次接触 Docker 的人来说能得到最好的支持且非常简单。</p>
<p>因此我希望你能看到容器化的价值所在，现在我们开始 Docker 化我们的第一个服务。创建一个 Dockerfile <code>$ touch consignment-service/Dockerfile</code></p>
<div class="highlight"><pre><span></span>FROM alpine:latest

RUN mkdir /app
WORKDIR /app
ADD consignment-service /app/consignment-service

CMD [&quot;./consignment-service&quot;]
</pre></div>


<p>如果你工作在 Linux，你可能遇到使用 Alpine 的问题。如果你正在一台Linux 机器上阅读这篇文章，简单的用<code>debian</code>替换<code>alpine</code>，然后你就能运行了。稍后我们将会介绍一种更好的方式来构建我们的二进制文件。</p>
<p>首先，我们会将最近版本的<a href="https://www.alpinelinux.org">Linux Alpine</a>拉取下来。<a href="https://www.alpinelinux.org">Linux Alpine</a>是一个轻量级的 Linux 发行版，为了 web 应用 Docker 化而开发和优化。换句话说，<a href="https://www.alpinelinux.org">Linux Alpine</a>拥有足够的依赖和运行时功能来运行大多数应用程序。这意味着它的镜像体积大约为8mb。相比之下，一个 Ubuntu VM大约1GB，你就能看出为什么 Docker 镜像对微服务与云计算变的更自然舒适。</p>
<p>接下来，我们创建一个新的目录来存放应用程序，并将上下文目录设置为我们的新目录。这是以便我们的应用目录作为默认目录。然后我们添加已编译过的二进制文件到 Docker 容器，并运行。</p>
<p>现在更新我们的 Makefile 的 build 选项来构建我们的 docker 镜像。</p>
<div class="highlight"><pre><span></span>build:
...
GOOS=linux GOARCH=amd64 go build
docker build -t consignment-service .
</pre></div>


<p>我们已经在这里添加了两个步骤，然后我会详细的解释它们。首先，我们会构建我们的 Go 二进制文件。你会注意到在运行<code>$ go build</code>之前设置了两个环境变量。GOOS 和 GOARCH 允许你为了另外的操作系统交叉编译。直到我使用 Macbook 之前，我不能编译一个 go 二进制文件并在 Docker 容器中运行使用 Linux 中编译的。这个二进制文件在你的 Docker 容器中将毫无意义，并且会抛出一个错误。</p>
<p>我第二步添加的是 docker 构建过程。这将会读取你的 Dockerfile，使用名称<code>consignment-service</code>构建一个镜像，句号表示一个目录路径，我们只希望在当前目录完成构建过程。</p>
<p>我要添加一个新条目到 Makefile：</p>
<div class="highlight"><pre><span></span><span class="n">run</span><span class="o">:</span>
<span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="mi">50051</span><span class="o">:</span><span class="mi">50051</span> <span class="n">consignment</span><span class="o">-</span><span class="n">service</span>
</pre></div>


<p>然后，我们运行货物服务(consignment-service) 的 docker 镜像，开放50051端口。因为 Docker 运行中一个独立的网络层，你需要将容器内部的端口转发到自己的主机上。你可以通过改变第一段来转发内部端口到一个新的端口。例如，如果你想将这个服务运行在8080端口，你可以更改-p 参数到<code>8080:50051</code>。你也能使用<code>-d</code> 参数来使一个容器在后台运行。例如<code>docker run -d -p 50051:50051 consignment-service</code>。</p>
<p><a href="https://docs.docker.com/engine/userguide/networking/">你可以通过阅读这篇文章了解更多关于 Docker 网络是如何运行的</a>。</p>
<p>运行<code>$ make run</code>，然后在一个独立的终端面板，再次运行你的命令行客户端<code>$ go run cli.go</code> 并再次确认仍在运行。</p>
<p>当你运行<code>$ docker build</code>，你正在构建你的代码和运行时环境到 docker 镜像中。Docker 镜像是可移植的快照，它们是互相依赖的。你可以通过将镜像发布到 docker hub 来分享你的镜像。对于 Docker 镜像来说，就像某种 npm，或者 yum 仓库。当你 在你的 Dockerfile 中定义一个<code>FROM</code>时，你就在告诉 docker，从 docker hub 拉取那个镜像来作为你的基础镜像。你可以在后面继承或者重载镜像文件的一部分，通过重定义成为你自己的。我们不会发布我们的 docker 镜像，但是可以随时使用 docker hub，并且注意到任何一个软件已经容器化了。一些真正<a href="https://www.youtube.com/watch?v=GsLZz8cZCzc">卓越的事情</a>都已经容器化了。</p>
<p>Dockerfile 中的每一个声明都会在它们第一次编译的时候被缓存下来。这样节省了每次进行更改时重新构建整个运行时的时间。Docker 足够聪明来计算出哪部分是被修改过的，哪部分需要重新构建。这样使得构建过程难以置信的快。</p>
<p>关于容器解释的足够了！让我们回到代码上来。</p>
<p>当创建一个 gRPC 服务时，为了创建连接，会有相当多的样本文件代码，并且你还不得不把服务地址硬编码到客户端中，或者其他为了连接上的服务中。这是棘手的，因为当你正在云上运行服务时，他们可能不会使用相同的 host，在重新部署一个服务后，他们的地址或者 ip 可能会发生改变。</p>
<p>这里就是服务发现发挥作用的地方。服务发现将你所有的服务和它们的位置保存下来。每一个服务在运行时会自己注册，在关闭时会注销。每一个服务都分配了有一个名称或者 id。这样尽管它有了一个新的 ip 地址或者新的 host，服务名称也会保持不变，你不需要更新调用这个服务的其他服务。</p>
<p>典型地，这个问题有很多处理方法，但是就像编程里的大多数事情一样，如果某个人已经处理了这个问题，那就没有必要重新造轮子。一个以极好的清晰度和易用性解决这些问题的人是 <a href="https://github.com/micro/go-micro">Go-micro</a>的创始人@chuhnk(Asim Aslam)。</p>
<h2>Go-micro</h2>
<p>Go-micro 是一个用 Go 编写的功能强大的微服务框架，绝大部分用 Go。你可以使用 <a href="https://github.com/micro/micro/tree/master/car">Sidecar</a> 来与其他语言通信。</p>
<p>Go-micro 拥有在微服务上很有用的特性。但是我们将会用它解决最常见的问题开始，那就是服务发现。</p>
<p>为了使用 go-micro，我们需要在我们的服务中加入几处更新。Go-micro 继承了 protoc 插件，在这种情况下，可以替换我们正在使用的标准 gRPC 插件。下面通过更改 Makefile 来替换它。</p>
<p>保证已经安装了 go-micro 依赖：</p>
<div class="highlight"><pre><span></span>go get -u github.com/micro/protobuf/<span class="o">{</span>proto,proto-gen-go<span class="o">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">build</span><span class="o">:</span>
    <span class="n">protoc</span> <span class="o">-</span><span class="n">I</span><span class="o">.</span> <span class="o">--</span><span class="n">go_out</span><span class="o">=</span><span class="n">plugins</span><span class="o">=</span><span class="n">micro</span><span class="o">:</span><span class="n">$</span><span class="o">(</span><span class="n">GOPATH</span><span class="o">)/</span><span class="n">src</span><span class="sr">/github.com/EwanValentine/shippy/</span><span class="n">consignment</span><span class="o">-</span><span class="n">service</span> <span class="o">\</span>
        <span class="n">proto</span><span class="sr">/consigment/</span><span class="n">consigment</span><span class="o">.</span><span class="na">proto</span>

    <span class="o">...</span>
</pre></div>


<p>我们已经更新了 Makefile 使用 go-micro 插件替换 gRPC 插件。现在我们将需要更新 <code>consignment-service/main.go</code> 文件。这将会抽象许多我们之前的 gRPC 代码。它可以轻松注册和启动我们的服务。</p>
<div class="highlight"><pre><span></span><span class="c1">// consignment-service/main.go</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="c1">// 导入 protobuf 生成的代码</span>
    <span class="s">&quot;fmt&quot;</span>

    <span class="nx">pb</span> <span class="s">&quot;github.com/EwanValentine/shippy/consignment-service/proto/consignment&quot;</span>
    <span class="nx">micro</span> <span class="s">&quot;github.com/micro/go-micro&quot;</span>
    <span class="s">&quot;golang.org/x/net/context&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">IRepository</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Create</span><span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nx">GetAll</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span>
<span class="p">}</span>

<span class="c1">// 仓库 - 虚拟仓库，模拟对某一类数据的使用，稍后将会真正实现。</span>
<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">consignments</span> <span class="p">[]</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">repo</span> <span class="o">*</span><span class="nx">Repository</span><span class="p">)</span> <span class="nx">Create</span><span class="p">(</span><span class="nx">consignment</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">updated</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">repo</span><span class="p">.</span><span class="nx">consignment</span><span class="p">,</span> <span class="nx">consignment</span><span class="p">)</span>
    <span class="nx">repo</span><span class="p">.</span><span class="nx">consignment</span> <span class="p">=</span> <span class="nx">updated</span>
    <span class="k">return</span> <span class="nx">consignment</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">repo</span> <span class="o">*</span><span class="nx">Repository</span><span class="p">)</span> <span class="nx">GetAll</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">repo</span><span class="p">.</span><span class="nx">consignment</span>
<span class="p">}</span>

<span class="c1">// Service 应当满足我们在protobuf 中定义的所有方法。</span>
<span class="c1">// 你可以在它生成的代码中的看到所有抽象接口来帮助你更好的编码。</span>
<span class="kd">type</span> <span class="nx">service</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">repo</span> <span class="nx">IRepository</span>
<span class="p">}</span>

<span class="c1">// createconsignment - 我们只在我们的服务中创建了一个方法。</span>
<span class="c1">// 这是一个创建方法，需要由 grpc server 处理的 context 和 request 参数，</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">service</span><span class="p">)</span> <span class="nx">CreateConsignment</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Consignment</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 保存 consignment</span>
    <span class="nx">consignment</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">repo</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="c1">// 返回符合我们在 protobuf 中定义的 Response 消息</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Response</span><span class="p">{</span><span class="nx">Created</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Consignment</span><span class="p">:</span> <span class="nx">consignment</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">service</span><span class="p">)</span> <span class="nx">GetConsignment</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">GetRequest</span><span class="p">,</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Response</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">consignments</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">repo</span><span class="p">.</span><span class="nx">GetAll</span><span class="p">()</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">Consignments</span> <span class="p">=</span> <span class="nx">consignments</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">repo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Repository</span><span class="p">{}</span>

    <span class="c1">// 创建一个新的服务，包含一些可选参数</span>
    <span class="nx">srv</span> <span class="o">:=</span> <span class="nx">micro</span><span class="p">.</span><span class="nx">NewService</span><span class="p">(</span>
        <span class="c1">// 名称必须与 protobuf 中定义的包名相同</span>
        <span class="nx">micro</span><span class="p">.</span><span class="nx">Name</span><span class="p">(</span><span class="s">&quot;go.micro.consignment&quot;</span><span class="p">),</span>
        <span class="nx">micro</span><span class="p">.</span><span class="nx">Version</span><span class="p">(</span><span class="s">&quot;latest&quot;</span><span class="p">),</span>    
    <span class="p">)</span>                                   

    <span class="c1">// Init 方法将会解析命令行参数</span>
    <span class="nx">srv</span><span class="p">.</span><span class="nx">Init</span><span class="p">()</span>

    <span class="c1">// 注册处理器</span>
    <span class="nx">pb</span><span class="p">.</span><span class="nx">RegisterShippingServiceHandler</span><span class="p">(</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">service</span><span class="p">(</span><span class="nx">repo</span><span class="p">))</span>

    <span class="c1">// 运行服务</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Run</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这里主要的改变在我们实例化 gRPC server 的方法，完整的抽象到 <code>micro.NewService()</code> 背后，以及处理注册服务。最后，<code>service.Run()</code> 函数处理到它自身的连接。与之前相似的是，我们注册，我们实现，但是这次使用了一种稍微不同的方法。</p>
<p>第二个最大的变化是服务方法自身，请求参数和返回值类型发生了改变，使用请求和返回结构体同时作为参数，然后返回错误信息。在方法内部，给响应赋值，然后由 go-micro 处理</p>
<p>最后，我们不用硬编码端口到代码中了。Go-micro 将会使用环境变量或者命令行参数进行配置。为了设置地址，使用<code>MICRO_SERVER_ADDRESS=:50051</code>。 也需要告诉我们的服务在本地运行时使用 <a href="https://en.wikipedia.org/wiki/Multicast_DNS">mdns</a>(多播dns)作为服务代理。最好不要在生产环境使用 <a href="https://en.wikipedia.org/wiki/Multicast_DNS">mdns</a> 作为服务发现，但是我们为了便利不得不在本地使用 Consul 或者 etcd。更多信息将在后面再说。</p>
<p>更新一下 Makefile 文件：</p>
<div class="highlight"><pre><span></span><span class="n">run</span><span class="o">:</span>
    <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="mi">50051</span><span class="o">:</span><span class="mi">50051</span> <span class="o">\</span>
        <span class="o">-</span><span class="n">e</span> <span class="n">MICRO_SERVER_ADDRESS</span><span class="o">=:</span><span class="mi">50051</span> <span class="o">\</span>
        <span class="o">-</span><span class="n">e</span> <span class="n">MICRO_REGISTRY</span><span class="o">=</span><span class="n">mdns</span> <span class="n">consignment</span><span class="o">-</span><span class="n">service</span>
</pre></div>


<p><code>-e</code> 参数表示环境变量，这代表你能将环境变量传递到容器内。你必须为每个变量加上 <code>-e</code> 参数，例如<code>-e ENV=staging -e DB_HOST=localhost</code>。</p>
<p>如果你现在运行 <code>$ make run</code>，你将会得到一个拥有服务发现的容器化的服务了。更新下命令行工具来利用它。</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
    <span class="o">...</span>
    <span class="s2">&quot;github.com/micro/go-micro/cmd&quot;</span>
    <span class="n">microclient</span> <span class="s2">&quot;github.com/micro/go-micro/client&quot;</span>
<span class="p">)</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cmd</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>

    <span class="o">//</span> <span class="err">创建一个新的</span> <span class="n">greeter</span> <span class="err">客户端</span>
    <span class="n">client</span> <span class="p">:</span><span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">NewShippingServiceClient</span><span class="p">(</span><span class="s2">&quot;go.micro.srv.consignment&quot;</span><span class="p">,</span> <span class="n">microclient</span><span class="o">.</span><span class="n">DefaultClient</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p><a href="https://github.com/EwanValentine/shippy/blob/tutorial-2/consignment-cli/cli.go">在这里查看完整文件</a></p>
<p>我们在创建客户端的时候引用了 go-micro 的库，并且使用 go-micro 的客户端代码替换掉了已存在的连接代码，使用服务重排而不是通过地址直连。</p>
<p>如果你想要运行客户端代码，你会发现它是不能运行的。这是因为我们的服务正在拥有独立的 <a href="https://en.wikipedia.org/wiki/Multicast_DNS">mdns</a> 的容器内部运行，跟宿主机使用的 <a href="https://en.wikipedia.org/wiki/Multicast_DNS">mdns</a> 是有区别的。解决它们最简单的方法是保证客户端和服务端同时运行在同样的环境下，使用同样的 host，同样的网络层。下面创建一个 Makefile <code>consignment-cli/Makefile</code>，加入一些内容。</p>
<div class="highlight"><pre><span></span><span class="n">build</span><span class="o">:</span>
    <span class="n">GOOS</span><span class="o">=</span><span class="n">linux</span> <span class="n">GOARCH</span><span class="o">=</span><span class="n">amd64</span> <span class="n">go</span> <span class="n">build</span>
    <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">consignment</span><span class="o">-</span><span class="n">cli</span> <span class="o">.</span>

<span class="n">run</span><span class="o">:</span>
    <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">e</span> <span class="n">MICRO_REGISTRY</span><span class="o">=</span><span class="n">mdns</span> <span class="n">consignment</span><span class="o">-</span><span class="n">cli</span>
</pre></div>


<p>与之前一样，想要为 Linux 系统构建二进制文件。当我们运行 docker 镜像，我们希望将环境变量传递给 go-micro 使用 mdns。</p>
<p>现在为命令行工具创建 Dockerfile：</p>
<div class="highlight"><pre><span></span>FORM alpine:latest

RUN mkdir -p /app
WORKDIR /app

ADD consignment.json /app/consignment.json
ADD consignment-cli /app/consignment-cli

CMD [&quot;./consignment-cli&quot;]
</pre></div>


<p>除了会将 json 文件添加进去外，与服务的 Dockerfile 十分相似</p>
<p>现在，当你在 <code>consignment-cli</code> 目录下运行 <code>$ make run</code> ，与之前一样，你将会看到 <code>created: true</code>。</p>
<p>在早些时候，我提到你需要将基础镜像从 Linux 替换为 Debian。现在可以看到一些 Docker 的新特性了：多步构建。这样允许在一个 Dockerfile 钟使用多个 Docker 镜像。</p>
<p>尤其是在我们这种情况是非常有用的，我们可以使用一个镜像构建二进制文件和所有的依赖等等，然后使用第二个镜像来运行。让我们来试试，我会在代码旁边加上一些注释：</p>
<div class="highlight"><pre><span></span># consignment-service/Dockerfile

# 我们使用官方的 Golang 镜像，包含所有构建工具和库。特别注意 `as builder`，
# 这是在给我们的容器命名，我们在后面可以直接引用。
FROM golang:1.9.0 as builder

# 为当前服务设置工作区
WORKDIR /go/src/github.com/EwanValentine/shippy/consignment-service

# 将当前代码复制到工作区
COPY . .

# 在这里拉取一个依赖管理工具：godep。我们将会使用 dep 而不是 go get
# 使用子包（sub-packages)）来解决一些问题
RUN go get -u github.com/golang/dep/cmd/dep

# 创建一个 dep 项目，运行 `ensure`，将会拉取这个目录下的所有的依赖
RUN dep init &amp;&amp; dep ensure

# 为了能够在 Alpine 中运行，需要使用几个参数来构建二进制文件
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo .

# 在这里运行第二个 FROM 语句，虽然很奇怪，但是这告诉 Docker 使用这个镜像开始一个新的构建过程
FROM alpine:latest

# 安全相关的包，最好能有
RUN apk --no-cache add ca-certificates

# 与之前一样，为 app 创建一个目录
RUN mkdir /app
WORKDIR /app

# 这里不再使用从宿主机上复制二进制文件，而是通过这次构建的上下文，从 builder 容器中拉取。
# 这会进入之前的容器，找到构件好的二进制文件，然后拉取到现在这个容器。
COPY --from=builder /go/src/github.com/EwanValentine/shippy/consignment-service/consignment-service .

# 运行二进制文件，这次我们使用正确的包和运行时在独立的容器中构建
CMD [&quot;./consignment-service&quot;]
</pre></div>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'https-blog-ooops-me';
      var disqus_identifier = window.location.href;
      (function () {
        var s = document.createElement('script'); s.async = true;
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//https-blog-ooops-me.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
  </script>
    </div>
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?67d2b3355046511d3ad9eef9c65d2a41";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();


  var hitokoto = document.getElementById('hitokoto');
  if (hitokoto) {
    var xhr = new XMLHttpRequest();
    xhr.open('get', 'https://v1.hitokoto.cn');
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        var data = JSON.parse(xhr.responseText);
        hitokoto.innerText = data.hitokoto;
      }
    }
    xhr.send();
  }
    </script>
  </body>
</html>